#!/usr/bin/env python3

'''continuous_loop_to_kml.py - Continuously rewrites a kml file as new
data lines appear in a CODAR Loop file during the processing of APM
data. This allows the operator to observe the "current" transponder
location in Google Earth as SeaSonde Loop Diagnostics processes the
data.

n.b., Incompatible with python 2; requires python 3.

continuous_loop_to_kml.py loops endlessly, with a 1-second delay
between iterations (press Ctrl-C to escape), grabbing the latest line
from whatever the most recent Loop file is in
/Codar/SeaSonde/Data/Loops/ (the standard location for Loop files on
CODAR Macs).

The user must provide the path to the GPS file from the APM. This file
can be a .gpx file, but this requires that the gpxpy python package
be installed, which can be difficult on an older Mac. If gpxpy is not
available, the GPS file must instead be an ASCII file consisting of
lines of the form
   48.4166818,-124.0477753,2021-09-24T22:15:56
(i.e., comma-separated values of decimal latitude, decimal longitude,
and time).

A .gpx file can be converted to CSV format using an online converter
like the one at https://mygeodata.cloud (unlike many online
converters, this one returns time in addition to latitude and
longitude). You could also use the gpsbabel program. e.g.,
   gpsbabel -t -i gpx -f apm.gpx -x nuketypes,waypoints,routes -o unicsv -F apm.csv

You'll need to convert the resulting CSV file into the specific
lat,lon,time format required by this program, possibly using a
combination of sed, awk, and/or python. Here's the conversion of the
CSV file generated by gpsbabel in the example above:
   cat apm.csv | sed -n '2,$ p' | sed 's#/#-#g' | awk -F , '{printf "%f,%f,%sT%s\n",$2,$3,$8,$9}' > apm_formatted.csv
The exact column numbers for awk to output ($2, $3, etc.) will depend
on the format of your particular CSV file.

If you aren't a sed/awk wizard, converting to a particular CSV
format can also be done in a spreadsheet program like Excel.

Output from continuous_loop_to_kml.py is to the file
/Users/codar/Public/continuous_loop_to_kml.kml. This location was
chosen because it will likely be browseable from other computers on
your network. This will allow you to run SeaSonde Loop Diagnostics on
one computer while viewing the associated GPS data "live" on another
computer using Google Earth, making it unnecessary to install Google
Earth on your data-processing computer.

How to use this program

   1) Convert the .gpx file to the required CSV format as described
   above and put it somewhere on your SeaSonde processing computer. If
   your processing computer has the gpxpy python package installed,
   this conversion won't be necessary.

   2) Run this script on the SeaSonde processing computer with the
   syntax:
      python3 continuous_loop_to_kml.py path_to_gps_file

   3) In Google Earth (either on the processing computer or another
   machine on the same network), select
      Add >> Network Link
   and browse to the continuous_loop_to_kml.kml file (you may need to
   do this after the following step if there are no existing Loop
   files yet). In the Refresh tab, set the view to refresh
   "periodically" and set the refresh period to 1 second.

   4) On your processing computer, run SeaSonde Acquisition with Loop
   Diagnostics selected as usual. The Loop file that is generated will
   be detected automatically by this script and the GPS location will
   begin to be displayed in Google Earth.

Syntax:
   python3 continuous_loop_to_kml.py gpsFile

Example:
   python3 continuous_loop_to_kml.py /tmp/all_cropped.gpx

kpb@oceannetworks.ca

################################################################
REVISION HISTORY

2021-10-08, kpb--Created.

################################################################

'''

import os, sys, time
import datetime as dt
import subprocess
import numpy as np
import glob

# Directories suitable for a Mac running SeaSonde.
LOOP_DIR = '/Codar/SeaSonde/Data/Loops/'

# ...Putting the kml file in "Public" should mean that Google
# Earth running on another computer can access it.
KML_DIR = '/Users/codar/Public/' 
kmlFile = os.path.join(KML_DIR,'continuous_loop_to_kml.kml')

################################################################
def even_simpler_kml(lat,lon,thisTime,kmlFile):
    # Outputs a .kml file with a single data point. Replaces
    # the simplekml package, which is tricky to install on older Macs.

    # For safety, check that file being written to is a .kml file
    # (don't want to accidentally overwrite some other file).
    kmlFileExt = os.path.splitext(kmlFile)[1]
    if not kmlFileExt == '.kml':
        raise Exception("File being written, %s, is not a .kml file. Aborting" % (kmlFile))

    timeStr = thisTime.strftime('%Y-%m-%dT%H:%M:%S')

    # Emulate this format, output by simplekml:
    #
    # <?xml version="1.0" encoding="UTF-8"?>
    # <kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">
    #     <Document id="000">
    #         <Placemark id="002">
    #             <name>2021-09-24T22:15:56</name>
    #             <Point id="001">
    #                  <coordinates>-124.0477753,48.4,0.0</coordinates>
    #             </Point>
    #          </Placemark>
    #     </Document>
    # </kml>

    try:
        fid = open(kmlFile, 'w')
    except:
        raise Exception("Failed to open kml file %s. Aborting" % (kmlFile))

    fid.write('<?xml version="1.0" encoding="UTF-8"?>\n')
    fid.write('<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2">\n')
    fid.write('     <Document id="000">\n')
    fid.write('        <Placemark id="002">\n')
    str = "            <name>%s</name>\n')" % (timeStr)
    fid.write(str)
    fid.write('            <Point id="001">\n')
    str = "                 <coordinates>%f,%f,0.0</coordinates>\n')" % (lon,lat)
    fid.write(str)
    fid.write('            </Point>\n')
    fid.write('         </Placemark>\n')
    fid.write('    </Document>\n')
    fid.write('</kml>\n')
    fid.flush()
    fid.close()

################################################################
def parse_csv_file(inFile):
    # Parses comma-separated file of timestamped GPS positions. Each line should have format:
    #    decimalLat,decimalLon,yyyy-mm-ddTHH:MM:SS
    # e.g.,
    #    48.4166818,-124.0477753,2021-09-24T22:15:56
    gps_fid = open(gpsFile, 'r')

    thisLine = 'dummy'
    gpsLats = []
    gpsLons = []
    gpsTimes = []
    while len(thisLine) > 0: 
        thisLine = gps_fid.readline()
        if len(thisLine) > 0:
            strs = thisLine.split(',')
            gpsLats.append(float(strs[0]))
            gpsLons.append(float(strs[1]))
            thisDatetime = dt.datetime.strptime(strs[2].strip(),'%Y-%m-%dT%H:%M:%S')
            gpsTimes.append(thisDatetime)
            #gpsTimes.append(point.time.replace(tzinfo=None))

    gps_fid.close()
    gpsLats = np.array(gpsLats)
    gpsLons = np.array(gpsLons)
    gpsElapsedDays = np.array([(x - epoch).total_seconds()/(24*3600) for x in gpsTimes])

    return gpsLats, gpsLons, gpsElapsedDays

################################################################
def parse_gpx_file(inFile):
    # gpsLats, gpsLons, gpsElapsedDays = parse_gpx_file(gpsFile)
    gps_fid = open(gpsFile, 'r')
    gpx = gpxpy.parse(gps_fid)
    gps_fid.close()

    gpsLats = []
    gpsLons = []
    gpsTimes = []
    for track in gpx.tracks:
        for segment in track.segments:
            for point in segment.points:
                gpsLats.append(point.latitude)
                gpsLons.append(point.longitude)
                gpsTimes.append(point.time.replace(tzinfo=None))

    gpsLats = np.array(gpsLats)
    gpsLons = np.array(gpsLons)
    gpsElapsedDays = np.array([(x - epoch).total_seconds()/(24*3600) for x in gpsTimes])
    return gpsLats, gpsLons, gpsElapsedDays
            
################################################################
def endless_loop():
    print("Press Ctrl-C to exit.")
    while True:
        # Pause before each iteration.
        time.sleep(1)

        # Find newest Loop file in Loop data directory.
        loopFiles = glob.glob(os.path.join(LOOP_DIR,'*.loop'))
        if len(loopFiles) < 1:
            print("No loop file found. Skipping this iteration.")
            continue

        loopFile = max(loopFiles, key=os.path.getctime)

        # Get time of last Loop entry.
        # cat /tmp/LOOP_VJOR_210924_195724x8.loop| grep -v % | tail -1 | awk '{printf "%sT%s",$19,$20}'
        cmd = "cat " + loopFile + "| grep -v % | tail -1 | awk '{printf \"%sT%s\",$19,$20}'"
        process = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, shell=True)

        if len(process.stdout) < 15:
            print("Time string from Loop file is of wrong length. Skipping this iteration.")
            continue

        try:
            loopDatetime = dt.datetime.strptime(process.stdout,'%Y%m%dT%H%M%S')
        except:
            print("Failed to convert string from Loop file to datetime. Skipping this iteration.")
            continue
            
        # Interp doesn't work with datetimes. Need to convert to float.
        loopTimeInDays = (loopDatetime - epoch).total_seconds()/(24*3600)

        # Find lat/lon in GPS data corresponding to this time from the Loop file.
        try:
            interpLat = np.interp(loopTimeInDays, gpsElapsedDays, gpsLats)
            interpLon = np.interp(loopTimeInDays, gpsElapsedDays, gpsLons)
        except:
            print("Failed to interpolate lat/lon to the current time value. Skipping this iteration.")
            continue

        # Write kml file with this lat/lon.
        even_simpler_kml(interpLat,interpLon,loopDatetime,kmlFile)

    # end while True

################################################################
if __name__ == '__main__':
    if len(sys.argv)==2:
        gpsFile = sys.argv[1]

        if not os.path.exists(LOOP_DIR):
          raise Exception("Loop directory %s does not exist. Aborting" % (LOOP_DIR))

        if not os.path.exists(gpsFile):
          raise Exception("Specified gps file %s does not exist. Aborting" % (gpsFile))

    else:
        raise SyntaxError("Number of arguments must be two.")

    epoch = dt.datetime.utcfromtimestamp(0)
    #epoch = dt.datetime.utcfromtimestamp(0).replace(tzinfo=None)

    gpsFileExt = os.path.splitext(gpsFile)[1]

    # Parse the gps file.
    if gpsFileExt == '.gpx':
        gpsFileFormat = 'gpx'
        try:
            import gpxpy
        except:
            print("Unable to parse .gpx format file because the gpxpy package is not available.")
            print("Convert your .gpx file to a comma-separated ASCII file and use that instead.")
            print("Format should be decimal latitude, decimal longitude, time, with time format yyyy-mm-ddTHH:MM:SS")
            raise Exception("Aborting.")
    else:
        gpsFileFormat = 'csv'
    
    if gpsFileFormat == 'gpx':
        try:
            gpsLats, gpsLons, gpsElapsedDays = parse_gpx_file(gpsFile)
        except:
            raise Exception("Failed to parse gpx file %s. Aborting" % (gpsFile))            
    else:
        # Parse CSV file.
        try:
            gpsLats, gpsLons, gpsElapsedDays = parse_csv_file(gpsFile)
        except:
            raise Exception("Failed to parse CSV file %s. Aborting" % (gpsFile))            
    
    print("Starting endless loop.")
    endless_loop()
    print("Endless loop halted.")
    
    sys.exit()
